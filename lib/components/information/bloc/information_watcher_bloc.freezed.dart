// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'information_watcher_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$InformationWatcherEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<InformationModel> informationItemsModel)
        updated,
    required TResult Function() loadNextItems,
    required TResult Function(dynamic value) filter,
    required TResult Function(Object error, StackTrace stack) failure,
    required TResult Function(InformationModel informationModel, bool isLiked)
        like,
    required TResult Function(InformationModel informationModel, bool isLiked)
        changeLike,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<InformationModel> informationItemsModel)? updated,
    TResult? Function()? loadNextItems,
    TResult? Function(dynamic value)? filter,
    TResult? Function(Object error, StackTrace stack)? failure,
    TResult? Function(InformationModel informationModel, bool isLiked)? like,
    TResult? Function(InformationModel informationModel, bool isLiked)?
        changeLike,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<InformationModel> informationItemsModel)? updated,
    TResult Function()? loadNextItems,
    TResult Function(dynamic value)? filter,
    TResult Function(Object error, StackTrace stack)? failure,
    TResult Function(InformationModel informationModel, bool isLiked)? like,
    TResult Function(InformationModel informationModel, bool isLiked)?
        changeLike,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_Updated value) updated,
    required TResult Function(_LoadNextItems value) loadNextItems,
    required TResult Function(_Filter value) filter,
    required TResult Function(_Failure value) failure,
    required TResult Function(_Like value) like,
    required TResult Function(_ChangeLike value) changeLike,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_Updated value)? updated,
    TResult? Function(_LoadNextItems value)? loadNextItems,
    TResult? Function(_Filter value)? filter,
    TResult? Function(_Failure value)? failure,
    TResult? Function(_Like value)? like,
    TResult? Function(_ChangeLike value)? changeLike,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_Updated value)? updated,
    TResult Function(_LoadNextItems value)? loadNextItems,
    TResult Function(_Filter value)? filter,
    TResult Function(_Failure value)? failure,
    TResult Function(_Like value)? like,
    TResult Function(_ChangeLike value)? changeLike,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InformationWatcherEventCopyWith<$Res> {
  factory $InformationWatcherEventCopyWith(InformationWatcherEvent value,
          $Res Function(InformationWatcherEvent) then) =
      _$InformationWatcherEventCopyWithImpl<$Res, InformationWatcherEvent>;
}

/// @nodoc
class _$InformationWatcherEventCopyWithImpl<$Res,
        $Val extends InformationWatcherEvent>
    implements $InformationWatcherEventCopyWith<$Res> {
  _$InformationWatcherEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$InformationWatcherEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$StartedImpl implements _Started {
  const _$StartedImpl();

  @override
  String toString() {
    return 'InformationWatcherEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<InformationModel> informationItemsModel)
        updated,
    required TResult Function() loadNextItems,
    required TResult Function(dynamic value) filter,
    required TResult Function(Object error, StackTrace stack) failure,
    required TResult Function(InformationModel informationModel, bool isLiked)
        like,
    required TResult Function(InformationModel informationModel, bool isLiked)
        changeLike,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<InformationModel> informationItemsModel)? updated,
    TResult? Function()? loadNextItems,
    TResult? Function(dynamic value)? filter,
    TResult? Function(Object error, StackTrace stack)? failure,
    TResult? Function(InformationModel informationModel, bool isLiked)? like,
    TResult? Function(InformationModel informationModel, bool isLiked)?
        changeLike,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<InformationModel> informationItemsModel)? updated,
    TResult Function()? loadNextItems,
    TResult Function(dynamic value)? filter,
    TResult Function(Object error, StackTrace stack)? failure,
    TResult Function(InformationModel informationModel, bool isLiked)? like,
    TResult Function(InformationModel informationModel, bool isLiked)?
        changeLike,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_Updated value) updated,
    required TResult Function(_LoadNextItems value) loadNextItems,
    required TResult Function(_Filter value) filter,
    required TResult Function(_Failure value) failure,
    required TResult Function(_Like value) like,
    required TResult Function(_ChangeLike value) changeLike,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_Updated value)? updated,
    TResult? Function(_LoadNextItems value)? loadNextItems,
    TResult? Function(_Filter value)? filter,
    TResult? Function(_Failure value)? failure,
    TResult? Function(_Like value)? like,
    TResult? Function(_ChangeLike value)? changeLike,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_Updated value)? updated,
    TResult Function(_LoadNextItems value)? loadNextItems,
    TResult Function(_Filter value)? filter,
    TResult Function(_Failure value)? failure,
    TResult Function(_Like value)? like,
    TResult Function(_ChangeLike value)? changeLike,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements InformationWatcherEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$UpdatedImplCopyWith<$Res> {
  factory _$$UpdatedImplCopyWith(
          _$UpdatedImpl value, $Res Function(_$UpdatedImpl) then) =
      __$$UpdatedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<InformationModel> informationItemsModel});
}

/// @nodoc
class __$$UpdatedImplCopyWithImpl<$Res>
    extends _$InformationWatcherEventCopyWithImpl<$Res, _$UpdatedImpl>
    implements _$$UpdatedImplCopyWith<$Res> {
  __$$UpdatedImplCopyWithImpl(
      _$UpdatedImpl _value, $Res Function(_$UpdatedImpl) _then)
      : super(_value, _then);

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? informationItemsModel = null,
  }) {
    return _then(_$UpdatedImpl(
      null == informationItemsModel
          ? _value._informationItemsModel
          : informationItemsModel // ignore: cast_nullable_to_non_nullable
              as List<InformationModel>,
    ));
  }
}

/// @nodoc

class _$UpdatedImpl implements _Updated {
  const _$UpdatedImpl(final List<InformationModel> informationItemsModel)
      : _informationItemsModel = informationItemsModel;

  final List<InformationModel> _informationItemsModel;
  @override
  List<InformationModel> get informationItemsModel {
    if (_informationItemsModel is EqualUnmodifiableListView)
      return _informationItemsModel;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_informationItemsModel);
  }

  @override
  String toString() {
    return 'InformationWatcherEvent.updated(informationItemsModel: $informationItemsModel)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdatedImpl &&
            const DeepCollectionEquality()
                .equals(other._informationItemsModel, _informationItemsModel));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_informationItemsModel));

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdatedImplCopyWith<_$UpdatedImpl> get copyWith =>
      __$$UpdatedImplCopyWithImpl<_$UpdatedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<InformationModel> informationItemsModel)
        updated,
    required TResult Function() loadNextItems,
    required TResult Function(dynamic value) filter,
    required TResult Function(Object error, StackTrace stack) failure,
    required TResult Function(InformationModel informationModel, bool isLiked)
        like,
    required TResult Function(InformationModel informationModel, bool isLiked)
        changeLike,
  }) {
    return updated(informationItemsModel);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<InformationModel> informationItemsModel)? updated,
    TResult? Function()? loadNextItems,
    TResult? Function(dynamic value)? filter,
    TResult? Function(Object error, StackTrace stack)? failure,
    TResult? Function(InformationModel informationModel, bool isLiked)? like,
    TResult? Function(InformationModel informationModel, bool isLiked)?
        changeLike,
  }) {
    return updated?.call(informationItemsModel);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<InformationModel> informationItemsModel)? updated,
    TResult Function()? loadNextItems,
    TResult Function(dynamic value)? filter,
    TResult Function(Object error, StackTrace stack)? failure,
    TResult Function(InformationModel informationModel, bool isLiked)? like,
    TResult Function(InformationModel informationModel, bool isLiked)?
        changeLike,
    required TResult orElse(),
  }) {
    if (updated != null) {
      return updated(informationItemsModel);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_Updated value) updated,
    required TResult Function(_LoadNextItems value) loadNextItems,
    required TResult Function(_Filter value) filter,
    required TResult Function(_Failure value) failure,
    required TResult Function(_Like value) like,
    required TResult Function(_ChangeLike value) changeLike,
  }) {
    return updated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_Updated value)? updated,
    TResult? Function(_LoadNextItems value)? loadNextItems,
    TResult? Function(_Filter value)? filter,
    TResult? Function(_Failure value)? failure,
    TResult? Function(_Like value)? like,
    TResult? Function(_ChangeLike value)? changeLike,
  }) {
    return updated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_Updated value)? updated,
    TResult Function(_LoadNextItems value)? loadNextItems,
    TResult Function(_Filter value)? filter,
    TResult Function(_Failure value)? failure,
    TResult Function(_Like value)? like,
    TResult Function(_ChangeLike value)? changeLike,
    required TResult orElse(),
  }) {
    if (updated != null) {
      return updated(this);
    }
    return orElse();
  }
}

abstract class _Updated implements InformationWatcherEvent {
  const factory _Updated(final List<InformationModel> informationItemsModel) =
      _$UpdatedImpl;

  List<InformationModel> get informationItemsModel;

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdatedImplCopyWith<_$UpdatedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadNextItemsImplCopyWith<$Res> {
  factory _$$LoadNextItemsImplCopyWith(
          _$LoadNextItemsImpl value, $Res Function(_$LoadNextItemsImpl) then) =
      __$$LoadNextItemsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadNextItemsImplCopyWithImpl<$Res>
    extends _$InformationWatcherEventCopyWithImpl<$Res, _$LoadNextItemsImpl>
    implements _$$LoadNextItemsImplCopyWith<$Res> {
  __$$LoadNextItemsImplCopyWithImpl(
      _$LoadNextItemsImpl _value, $Res Function(_$LoadNextItemsImpl) _then)
      : super(_value, _then);

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadNextItemsImpl implements _LoadNextItems {
  const _$LoadNextItemsImpl();

  @override
  String toString() {
    return 'InformationWatcherEvent.loadNextItems()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadNextItemsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<InformationModel> informationItemsModel)
        updated,
    required TResult Function() loadNextItems,
    required TResult Function(dynamic value) filter,
    required TResult Function(Object error, StackTrace stack) failure,
    required TResult Function(InformationModel informationModel, bool isLiked)
        like,
    required TResult Function(InformationModel informationModel, bool isLiked)
        changeLike,
  }) {
    return loadNextItems();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<InformationModel> informationItemsModel)? updated,
    TResult? Function()? loadNextItems,
    TResult? Function(dynamic value)? filter,
    TResult? Function(Object error, StackTrace stack)? failure,
    TResult? Function(InformationModel informationModel, bool isLiked)? like,
    TResult? Function(InformationModel informationModel, bool isLiked)?
        changeLike,
  }) {
    return loadNextItems?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<InformationModel> informationItemsModel)? updated,
    TResult Function()? loadNextItems,
    TResult Function(dynamic value)? filter,
    TResult Function(Object error, StackTrace stack)? failure,
    TResult Function(InformationModel informationModel, bool isLiked)? like,
    TResult Function(InformationModel informationModel, bool isLiked)?
        changeLike,
    required TResult orElse(),
  }) {
    if (loadNextItems != null) {
      return loadNextItems();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_Updated value) updated,
    required TResult Function(_LoadNextItems value) loadNextItems,
    required TResult Function(_Filter value) filter,
    required TResult Function(_Failure value) failure,
    required TResult Function(_Like value) like,
    required TResult Function(_ChangeLike value) changeLike,
  }) {
    return loadNextItems(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_Updated value)? updated,
    TResult? Function(_LoadNextItems value)? loadNextItems,
    TResult? Function(_Filter value)? filter,
    TResult? Function(_Failure value)? failure,
    TResult? Function(_Like value)? like,
    TResult? Function(_ChangeLike value)? changeLike,
  }) {
    return loadNextItems?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_Updated value)? updated,
    TResult Function(_LoadNextItems value)? loadNextItems,
    TResult Function(_Filter value)? filter,
    TResult Function(_Failure value)? failure,
    TResult Function(_Like value)? like,
    TResult Function(_ChangeLike value)? changeLike,
    required TResult orElse(),
  }) {
    if (loadNextItems != null) {
      return loadNextItems(this);
    }
    return orElse();
  }
}

abstract class _LoadNextItems implements InformationWatcherEvent {
  const factory _LoadNextItems() = _$LoadNextItemsImpl;
}

/// @nodoc
abstract class _$$FilterImplCopyWith<$Res> {
  factory _$$FilterImplCopyWith(
          _$FilterImpl value, $Res Function(_$FilterImpl) then) =
      __$$FilterImplCopyWithImpl<$Res>;
  @useResult
  $Res call({dynamic value});
}

/// @nodoc
class __$$FilterImplCopyWithImpl<$Res>
    extends _$InformationWatcherEventCopyWithImpl<$Res, _$FilterImpl>
    implements _$$FilterImplCopyWith<$Res> {
  __$$FilterImplCopyWithImpl(
      _$FilterImpl _value, $Res Function(_$FilterImpl) _then)
      : super(_value, _then);

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$FilterImpl(
      freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$FilterImpl implements _Filter {
  const _$FilterImpl(this.value);

  @override
  final dynamic value;

  @override
  String toString() {
    return 'InformationWatcherEvent.filter(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilterImpl &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FilterImplCopyWith<_$FilterImpl> get copyWith =>
      __$$FilterImplCopyWithImpl<_$FilterImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<InformationModel> informationItemsModel)
        updated,
    required TResult Function() loadNextItems,
    required TResult Function(dynamic value) filter,
    required TResult Function(Object error, StackTrace stack) failure,
    required TResult Function(InformationModel informationModel, bool isLiked)
        like,
    required TResult Function(InformationModel informationModel, bool isLiked)
        changeLike,
  }) {
    return filter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<InformationModel> informationItemsModel)? updated,
    TResult? Function()? loadNextItems,
    TResult? Function(dynamic value)? filter,
    TResult? Function(Object error, StackTrace stack)? failure,
    TResult? Function(InformationModel informationModel, bool isLiked)? like,
    TResult? Function(InformationModel informationModel, bool isLiked)?
        changeLike,
  }) {
    return filter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<InformationModel> informationItemsModel)? updated,
    TResult Function()? loadNextItems,
    TResult Function(dynamic value)? filter,
    TResult Function(Object error, StackTrace stack)? failure,
    TResult Function(InformationModel informationModel, bool isLiked)? like,
    TResult Function(InformationModel informationModel, bool isLiked)?
        changeLike,
    required TResult orElse(),
  }) {
    if (filter != null) {
      return filter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_Updated value) updated,
    required TResult Function(_LoadNextItems value) loadNextItems,
    required TResult Function(_Filter value) filter,
    required TResult Function(_Failure value) failure,
    required TResult Function(_Like value) like,
    required TResult Function(_ChangeLike value) changeLike,
  }) {
    return filter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_Updated value)? updated,
    TResult? Function(_LoadNextItems value)? loadNextItems,
    TResult? Function(_Filter value)? filter,
    TResult? Function(_Failure value)? failure,
    TResult? Function(_Like value)? like,
    TResult? Function(_ChangeLike value)? changeLike,
  }) {
    return filter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_Updated value)? updated,
    TResult Function(_LoadNextItems value)? loadNextItems,
    TResult Function(_Filter value)? filter,
    TResult Function(_Failure value)? failure,
    TResult Function(_Like value)? like,
    TResult Function(_ChangeLike value)? changeLike,
    required TResult orElse(),
  }) {
    if (filter != null) {
      return filter(this);
    }
    return orElse();
  }
}

abstract class _Filter implements InformationWatcherEvent {
  const factory _Filter(final dynamic value) = _$FilterImpl;

  dynamic get value;

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FilterImplCopyWith<_$FilterImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FailureImplCopyWith<$Res> {
  factory _$$FailureImplCopyWith(
          _$FailureImpl value, $Res Function(_$FailureImpl) then) =
      __$$FailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object error, StackTrace stack});
}

/// @nodoc
class __$$FailureImplCopyWithImpl<$Res>
    extends _$InformationWatcherEventCopyWithImpl<$Res, _$FailureImpl>
    implements _$$FailureImplCopyWith<$Res> {
  __$$FailureImplCopyWithImpl(
      _$FailureImpl _value, $Res Function(_$FailureImpl) _then)
      : super(_value, _then);

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
    Object? stack = null,
  }) {
    return _then(_$FailureImpl(
      error: null == error ? _value.error : error,
      stack: null == stack
          ? _value.stack
          : stack // ignore: cast_nullable_to_non_nullable
              as StackTrace,
    ));
  }
}

/// @nodoc

class _$FailureImpl implements _Failure {
  const _$FailureImpl({required this.error, required this.stack});

  @override
  final Object error;
  @override
  final StackTrace stack;

  @override
  String toString() {
    return 'InformationWatcherEvent.failure(error: $error, stack: $stack)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FailureImpl &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.stack, stack) || other.stack == stack));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(error), stack);

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FailureImplCopyWith<_$FailureImpl> get copyWith =>
      __$$FailureImplCopyWithImpl<_$FailureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<InformationModel> informationItemsModel)
        updated,
    required TResult Function() loadNextItems,
    required TResult Function(dynamic value) filter,
    required TResult Function(Object error, StackTrace stack) failure,
    required TResult Function(InformationModel informationModel, bool isLiked)
        like,
    required TResult Function(InformationModel informationModel, bool isLiked)
        changeLike,
  }) {
    return failure(error, stack);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<InformationModel> informationItemsModel)? updated,
    TResult? Function()? loadNextItems,
    TResult? Function(dynamic value)? filter,
    TResult? Function(Object error, StackTrace stack)? failure,
    TResult? Function(InformationModel informationModel, bool isLiked)? like,
    TResult? Function(InformationModel informationModel, bool isLiked)?
        changeLike,
  }) {
    return failure?.call(error, stack);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<InformationModel> informationItemsModel)? updated,
    TResult Function()? loadNextItems,
    TResult Function(dynamic value)? filter,
    TResult Function(Object error, StackTrace stack)? failure,
    TResult Function(InformationModel informationModel, bool isLiked)? like,
    TResult Function(InformationModel informationModel, bool isLiked)?
        changeLike,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(error, stack);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_Updated value) updated,
    required TResult Function(_LoadNextItems value) loadNextItems,
    required TResult Function(_Filter value) filter,
    required TResult Function(_Failure value) failure,
    required TResult Function(_Like value) like,
    required TResult Function(_ChangeLike value) changeLike,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_Updated value)? updated,
    TResult? Function(_LoadNextItems value)? loadNextItems,
    TResult? Function(_Filter value)? filter,
    TResult? Function(_Failure value)? failure,
    TResult? Function(_Like value)? like,
    TResult? Function(_ChangeLike value)? changeLike,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_Updated value)? updated,
    TResult Function(_LoadNextItems value)? loadNextItems,
    TResult Function(_Filter value)? filter,
    TResult Function(_Failure value)? failure,
    TResult Function(_Like value)? like,
    TResult Function(_ChangeLike value)? changeLike,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class _Failure implements InformationWatcherEvent {
  const factory _Failure(
      {required final Object error,
      required final StackTrace stack}) = _$FailureImpl;

  Object get error;
  StackTrace get stack;

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FailureImplCopyWith<_$FailureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LikeImplCopyWith<$Res> {
  factory _$$LikeImplCopyWith(
          _$LikeImpl value, $Res Function(_$LikeImpl) then) =
      __$$LikeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({InformationModel informationModel, bool isLiked});

  $InformationModelCopyWith<$Res> get informationModel;
}

/// @nodoc
class __$$LikeImplCopyWithImpl<$Res>
    extends _$InformationWatcherEventCopyWithImpl<$Res, _$LikeImpl>
    implements _$$LikeImplCopyWith<$Res> {
  __$$LikeImplCopyWithImpl(_$LikeImpl _value, $Res Function(_$LikeImpl) _then)
      : super(_value, _then);

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? informationModel = null,
    Object? isLiked = null,
  }) {
    return _then(_$LikeImpl(
      informationModel: null == informationModel
          ? _value.informationModel
          : informationModel // ignore: cast_nullable_to_non_nullable
              as InformationModel,
      isLiked: null == isLiked
          ? _value.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $InformationModelCopyWith<$Res> get informationModel {
    return $InformationModelCopyWith<$Res>(_value.informationModel, (value) {
      return _then(_value.copyWith(informationModel: value));
    });
  }
}

/// @nodoc

class _$LikeImpl implements _Like {
  const _$LikeImpl({required this.informationModel, required this.isLiked});

  @override
  final InformationModel informationModel;
  @override
  final bool isLiked;

  @override
  String toString() {
    return 'InformationWatcherEvent.like(informationModel: $informationModel, isLiked: $isLiked)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LikeImpl &&
            (identical(other.informationModel, informationModel) ||
                other.informationModel == informationModel) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked));
  }

  @override
  int get hashCode => Object.hash(runtimeType, informationModel, isLiked);

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LikeImplCopyWith<_$LikeImpl> get copyWith =>
      __$$LikeImplCopyWithImpl<_$LikeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<InformationModel> informationItemsModel)
        updated,
    required TResult Function() loadNextItems,
    required TResult Function(dynamic value) filter,
    required TResult Function(Object error, StackTrace stack) failure,
    required TResult Function(InformationModel informationModel, bool isLiked)
        like,
    required TResult Function(InformationModel informationModel, bool isLiked)
        changeLike,
  }) {
    return like(informationModel, isLiked);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<InformationModel> informationItemsModel)? updated,
    TResult? Function()? loadNextItems,
    TResult? Function(dynamic value)? filter,
    TResult? Function(Object error, StackTrace stack)? failure,
    TResult? Function(InformationModel informationModel, bool isLiked)? like,
    TResult? Function(InformationModel informationModel, bool isLiked)?
        changeLike,
  }) {
    return like?.call(informationModel, isLiked);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<InformationModel> informationItemsModel)? updated,
    TResult Function()? loadNextItems,
    TResult Function(dynamic value)? filter,
    TResult Function(Object error, StackTrace stack)? failure,
    TResult Function(InformationModel informationModel, bool isLiked)? like,
    TResult Function(InformationModel informationModel, bool isLiked)?
        changeLike,
    required TResult orElse(),
  }) {
    if (like != null) {
      return like(informationModel, isLiked);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_Updated value) updated,
    required TResult Function(_LoadNextItems value) loadNextItems,
    required TResult Function(_Filter value) filter,
    required TResult Function(_Failure value) failure,
    required TResult Function(_Like value) like,
    required TResult Function(_ChangeLike value) changeLike,
  }) {
    return like(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_Updated value)? updated,
    TResult? Function(_LoadNextItems value)? loadNextItems,
    TResult? Function(_Filter value)? filter,
    TResult? Function(_Failure value)? failure,
    TResult? Function(_Like value)? like,
    TResult? Function(_ChangeLike value)? changeLike,
  }) {
    return like?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_Updated value)? updated,
    TResult Function(_LoadNextItems value)? loadNextItems,
    TResult Function(_Filter value)? filter,
    TResult Function(_Failure value)? failure,
    TResult Function(_Like value)? like,
    TResult Function(_ChangeLike value)? changeLike,
    required TResult orElse(),
  }) {
    if (like != null) {
      return like(this);
    }
    return orElse();
  }
}

abstract class _Like implements InformationWatcherEvent {
  const factory _Like(
      {required final InformationModel informationModel,
      required final bool isLiked}) = _$LikeImpl;

  InformationModel get informationModel;
  bool get isLiked;

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LikeImplCopyWith<_$LikeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChangeLikeImplCopyWith<$Res> {
  factory _$$ChangeLikeImplCopyWith(
          _$ChangeLikeImpl value, $Res Function(_$ChangeLikeImpl) then) =
      __$$ChangeLikeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({InformationModel informationModel, bool isLiked});

  $InformationModelCopyWith<$Res> get informationModel;
}

/// @nodoc
class __$$ChangeLikeImplCopyWithImpl<$Res>
    extends _$InformationWatcherEventCopyWithImpl<$Res, _$ChangeLikeImpl>
    implements _$$ChangeLikeImplCopyWith<$Res> {
  __$$ChangeLikeImplCopyWithImpl(
      _$ChangeLikeImpl _value, $Res Function(_$ChangeLikeImpl) _then)
      : super(_value, _then);

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? informationModel = null,
    Object? isLiked = null,
  }) {
    return _then(_$ChangeLikeImpl(
      informationModel: null == informationModel
          ? _value.informationModel
          : informationModel // ignore: cast_nullable_to_non_nullable
              as InformationModel,
      isLiked: null == isLiked
          ? _value.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $InformationModelCopyWith<$Res> get informationModel {
    return $InformationModelCopyWith<$Res>(_value.informationModel, (value) {
      return _then(_value.copyWith(informationModel: value));
    });
  }
}

/// @nodoc

class _$ChangeLikeImpl implements _ChangeLike {
  const _$ChangeLikeImpl(
      {required this.informationModel, required this.isLiked});

  @override
  final InformationModel informationModel;
  @override
  final bool isLiked;

  @override
  String toString() {
    return 'InformationWatcherEvent.changeLike(informationModel: $informationModel, isLiked: $isLiked)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeLikeImpl &&
            (identical(other.informationModel, informationModel) ||
                other.informationModel == informationModel) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked));
  }

  @override
  int get hashCode => Object.hash(runtimeType, informationModel, isLiked);

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangeLikeImplCopyWith<_$ChangeLikeImpl> get copyWith =>
      __$$ChangeLikeImplCopyWithImpl<_$ChangeLikeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<InformationModel> informationItemsModel)
        updated,
    required TResult Function() loadNextItems,
    required TResult Function(dynamic value) filter,
    required TResult Function(Object error, StackTrace stack) failure,
    required TResult Function(InformationModel informationModel, bool isLiked)
        like,
    required TResult Function(InformationModel informationModel, bool isLiked)
        changeLike,
  }) {
    return changeLike(informationModel, isLiked);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<InformationModel> informationItemsModel)? updated,
    TResult? Function()? loadNextItems,
    TResult? Function(dynamic value)? filter,
    TResult? Function(Object error, StackTrace stack)? failure,
    TResult? Function(InformationModel informationModel, bool isLiked)? like,
    TResult? Function(InformationModel informationModel, bool isLiked)?
        changeLike,
  }) {
    return changeLike?.call(informationModel, isLiked);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<InformationModel> informationItemsModel)? updated,
    TResult Function()? loadNextItems,
    TResult Function(dynamic value)? filter,
    TResult Function(Object error, StackTrace stack)? failure,
    TResult Function(InformationModel informationModel, bool isLiked)? like,
    TResult Function(InformationModel informationModel, bool isLiked)?
        changeLike,
    required TResult orElse(),
  }) {
    if (changeLike != null) {
      return changeLike(informationModel, isLiked);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_Updated value) updated,
    required TResult Function(_LoadNextItems value) loadNextItems,
    required TResult Function(_Filter value) filter,
    required TResult Function(_Failure value) failure,
    required TResult Function(_Like value) like,
    required TResult Function(_ChangeLike value) changeLike,
  }) {
    return changeLike(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_Updated value)? updated,
    TResult? Function(_LoadNextItems value)? loadNextItems,
    TResult? Function(_Filter value)? filter,
    TResult? Function(_Failure value)? failure,
    TResult? Function(_Like value)? like,
    TResult? Function(_ChangeLike value)? changeLike,
  }) {
    return changeLike?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_Updated value)? updated,
    TResult Function(_LoadNextItems value)? loadNextItems,
    TResult Function(_Filter value)? filter,
    TResult Function(_Failure value)? failure,
    TResult Function(_Like value)? like,
    TResult Function(_ChangeLike value)? changeLike,
    required TResult orElse(),
  }) {
    if (changeLike != null) {
      return changeLike(this);
    }
    return orElse();
  }
}

abstract class _ChangeLike implements InformationWatcherEvent {
  const factory _ChangeLike(
      {required final InformationModel informationModel,
      required final bool isLiked}) = _$ChangeLikeImpl;

  InformationModel get informationModel;
  bool get isLiked;

  /// Create a copy of InformationWatcherEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ChangeLikeImplCopyWith<_$ChangeLikeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$InformationWatcherState {
  List<InformationModel> get informationModelItems =>
      throw _privateConstructorUsedError;
  List<InformationModel> get filteredInformationModelItems =>
      throw _privateConstructorUsedError;
  List<dynamic> get filters => throw _privateConstructorUsedError;
  LoadingStatus get loadingStatus => throw _privateConstructorUsedError;
  int get itemsLoaded => throw _privateConstructorUsedError;
  InformationFailure? get failure => throw _privateConstructorUsedError;

  /// Create a copy of InformationWatcherState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $InformationWatcherStateCopyWith<InformationWatcherState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InformationWatcherStateCopyWith<$Res> {
  factory $InformationWatcherStateCopyWith(InformationWatcherState value,
          $Res Function(InformationWatcherState) then) =
      _$InformationWatcherStateCopyWithImpl<$Res, InformationWatcherState>;
  @useResult
  $Res call(
      {List<InformationModel> informationModelItems,
      List<InformationModel> filteredInformationModelItems,
      List<dynamic> filters,
      LoadingStatus loadingStatus,
      int itemsLoaded,
      InformationFailure? failure});
}

/// @nodoc
class _$InformationWatcherStateCopyWithImpl<$Res,
        $Val extends InformationWatcherState>
    implements $InformationWatcherStateCopyWith<$Res> {
  _$InformationWatcherStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of InformationWatcherState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? informationModelItems = null,
    Object? filteredInformationModelItems = null,
    Object? filters = null,
    Object? loadingStatus = null,
    Object? itemsLoaded = null,
    Object? failure = freezed,
  }) {
    return _then(_value.copyWith(
      informationModelItems: null == informationModelItems
          ? _value.informationModelItems
          : informationModelItems // ignore: cast_nullable_to_non_nullable
              as List<InformationModel>,
      filteredInformationModelItems: null == filteredInformationModelItems
          ? _value.filteredInformationModelItems
          : filteredInformationModelItems // ignore: cast_nullable_to_non_nullable
              as List<InformationModel>,
      filters: null == filters
          ? _value.filters
          : filters // ignore: cast_nullable_to_non_nullable
              as List<dynamic>,
      loadingStatus: null == loadingStatus
          ? _value.loadingStatus
          : loadingStatus // ignore: cast_nullable_to_non_nullable
              as LoadingStatus,
      itemsLoaded: null == itemsLoaded
          ? _value.itemsLoaded
          : itemsLoaded // ignore: cast_nullable_to_non_nullable
              as int,
      failure: freezed == failure
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as InformationFailure?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res>
    implements $InformationWatcherStateCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<InformationModel> informationModelItems,
      List<InformationModel> filteredInformationModelItems,
      List<dynamic> filters,
      LoadingStatus loadingStatus,
      int itemsLoaded,
      InformationFailure? failure});
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$InformationWatcherStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of InformationWatcherState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? informationModelItems = null,
    Object? filteredInformationModelItems = null,
    Object? filters = null,
    Object? loadingStatus = null,
    Object? itemsLoaded = null,
    Object? failure = freezed,
  }) {
    return _then(_$InitialImpl(
      informationModelItems: null == informationModelItems
          ? _value._informationModelItems
          : informationModelItems // ignore: cast_nullable_to_non_nullable
              as List<InformationModel>,
      filteredInformationModelItems: null == filteredInformationModelItems
          ? _value._filteredInformationModelItems
          : filteredInformationModelItems // ignore: cast_nullable_to_non_nullable
              as List<InformationModel>,
      filters: null == filters
          ? _value._filters
          : filters // ignore: cast_nullable_to_non_nullable
              as List<dynamic>,
      loadingStatus: null == loadingStatus
          ? _value.loadingStatus
          : loadingStatus // ignore: cast_nullable_to_non_nullable
              as LoadingStatus,
      itemsLoaded: null == itemsLoaded
          ? _value.itemsLoaded
          : itemsLoaded // ignore: cast_nullable_to_non_nullable
              as int,
      failure: freezed == failure
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as InformationFailure?,
    ));
  }
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl(
      {required final List<InformationModel> informationModelItems,
      required final List<InformationModel> filteredInformationModelItems,
      required final List<dynamic> filters,
      required this.loadingStatus,
      required this.itemsLoaded,
      required this.failure})
      : _informationModelItems = informationModelItems,
        _filteredInformationModelItems = filteredInformationModelItems,
        _filters = filters;

  final List<InformationModel> _informationModelItems;
  @override
  List<InformationModel> get informationModelItems {
    if (_informationModelItems is EqualUnmodifiableListView)
      return _informationModelItems;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_informationModelItems);
  }

  final List<InformationModel> _filteredInformationModelItems;
  @override
  List<InformationModel> get filteredInformationModelItems {
    if (_filteredInformationModelItems is EqualUnmodifiableListView)
      return _filteredInformationModelItems;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filteredInformationModelItems);
  }

  final List<dynamic> _filters;
  @override
  List<dynamic> get filters {
    if (_filters is EqualUnmodifiableListView) return _filters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filters);
  }

  @override
  final LoadingStatus loadingStatus;
  @override
  final int itemsLoaded;
  @override
  final InformationFailure? failure;

  @override
  String toString() {
    return 'InformationWatcherState(informationModelItems: $informationModelItems, filteredInformationModelItems: $filteredInformationModelItems, filters: $filters, loadingStatus: $loadingStatus, itemsLoaded: $itemsLoaded, failure: $failure)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InitialImpl &&
            const DeepCollectionEquality()
                .equals(other._informationModelItems, _informationModelItems) &&
            const DeepCollectionEquality().equals(
                other._filteredInformationModelItems,
                _filteredInformationModelItems) &&
            const DeepCollectionEquality().equals(other._filters, _filters) &&
            (identical(other.loadingStatus, loadingStatus) ||
                other.loadingStatus == loadingStatus) &&
            (identical(other.itemsLoaded, itemsLoaded) ||
                other.itemsLoaded == itemsLoaded) &&
            (identical(other.failure, failure) || other.failure == failure));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_informationModelItems),
      const DeepCollectionEquality().hash(_filteredInformationModelItems),
      const DeepCollectionEquality().hash(_filters),
      loadingStatus,
      itemsLoaded,
      failure);

  /// Create a copy of InformationWatcherState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      __$$InitialImplCopyWithImpl<_$InitialImpl>(this, _$identity);
}

abstract class _Initial implements InformationWatcherState {
  const factory _Initial(
      {required final List<InformationModel> informationModelItems,
      required final List<InformationModel> filteredInformationModelItems,
      required final List<dynamic> filters,
      required final LoadingStatus loadingStatus,
      required final int itemsLoaded,
      required final InformationFailure? failure}) = _$InitialImpl;

  @override
  List<InformationModel> get informationModelItems;
  @override
  List<InformationModel> get filteredInformationModelItems;
  @override
  List<dynamic> get filters;
  @override
  LoadingStatus get loadingStatus;
  @override
  int get itemsLoaded;
  @override
  InformationFailure? get failure;

  /// Create a copy of InformationWatcherState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
